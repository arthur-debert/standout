#!/bin/bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

OUTPUT_ROOT="public"
TAG_PATTERN="standout-v*"
CLEAN_OUTPUT=false

usage() {
    echo "Usage: $0 [--output <dir>] [--tag-pattern <pattern>] [--clean]" >&2
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        --output)
            OUTPUT_ROOT="${2:-}"
            shift 2
            ;;
        --tag-pattern)
            TAG_PATTERN="${2:-}"
            shift 2
            ;;
        --clean)
            CLEAN_OUTPUT=true
            shift
            ;;
        -*)
            echo "Unknown option: $1" >&2
            usage
            exit 1
            ;;
        *)
            echo "Unexpected argument: $1" >&2
            usage
            exit 1
            ;;
    esac
done

if [[ -z "$OUTPUT_ROOT" ]]; then
    echo "Output directory cannot be empty." >&2
    exit 1
fi

if [[ "$OUTPUT_ROOT" != /* ]]; then
    OUTPUT_ROOT="$PROJECT_DIR/$OUTPUT_ROOT"
fi

cd "$PROJECT_DIR"

if [[ "$CLEAN_OUTPUT" == "true" ]]; then
    if [[ "$OUTPUT_ROOT" == "/" ]]; then
        echo "Refusing to clean the root directory." >&2
        exit 1
    fi
    rm -rf "$OUTPUT_ROOT"
fi

mkdir -p "$OUTPUT_ROOT"

mapfile -t TAGS < <(git tag -l "$TAG_PATTERN" | sort -V)
DOC_TAGS=()
for tag in "${TAGS[@]}"; do
    if git cat-file -e "$tag:book.toml" 2>/dev/null && git cat-file -e "$tag:docs/SUMMARY.md" 2>/dev/null; then
        DOC_TAGS+=("$tag")
    fi
done

if [[ ${#DOC_TAGS[@]} -eq 0 ]]; then
    echo "No tags matched $TAG_PATTERN with docs content." >&2
    exit 1
fi

echo "Earliest docs tag: ${DOC_TAGS[0]}"

for tag in "${DOC_TAGS[@]}"; do
    temp_dir="$(mktemp -d)"
    trap 'rm -rf "$temp_dir"' EXIT
    git archive --format=tar "$tag" | tar -x -C "$temp_dir"
    "$PROJECT_DIR/scripts/docs-versioned" "$tag" --output "$OUTPUT_ROOT" --source "$temp_dir"
    rm -rf "$temp_dir"
    trap - EXIT
done

"$PROJECT_DIR/scripts/docs-versioned" latest --output "$OUTPUT_ROOT" --source "$PROJECT_DIR"
