# Execution Model

Outstanding manages a pipeline from CLI input to rendered output. Understanding this flow helps you know where to hook in, what data is available at each stage, and how to extend behavior without fighting the framework.

## The Pipeline

```
Clap Parsing → Dispatch → Handler → Hooks → Rendering → Output
```

Each stage has a clear responsibility:

**Clap Parsing**: Your `clap::Command` definition is augmented with Outstanding's flags (`--output`, custom help) and parsed normally. Outstanding doesn't replace clap—it builds on top of it.

**Dispatch**: Outstanding extracts the *command path* from the parsed `ArgMatches`, navigating through subcommands to find the deepest match. It then looks up the registered handler for that path.

**Handler**: Your logic function executes. It receives the `ArgMatches` and a `CommandContext`, returning a `HandlerResult<T>`—either data to render, a silent marker, or binary content.

**Hooks**: If registered, hooks run at three points around the handler. They can validate, transform, or intercept without modifying handler logic.

**Rendering**: Handler output is serialized and passed through the template engine, producing styled terminal output (or structured data like JSON, depending on output mode).

**Output**: The result is written to stdout or a file.

This pipeline is what Outstanding manages for you—the glue code between "I have a clap definition" and "I want rich, testable output."

## Command Paths

A command path is a vector of strings representing the subcommand chain:

```
myapp db migrate --steps 5
```

The command path is `["db", "migrate"]`.

When you register commands with `AppBuilder`:

```rust
App::builder()
    .command("list", list_handler, "list.j2")
    .group("db", |g| g
        .command("migrate", migrate_handler, "db/migrate.j2")
        .command("status", status_handler, "db/status.j2"))
    .build()?
```

Outstanding builds an internal registry mapping paths to handlers:
- `["list"]` → `list_handler`
- `["db", "migrate"]` → `migrate_handler`
- `["db", "status"]` → `status_handler`

The command path is available in `CommandContext.command_path` for your handler to inspect, and uses dot notation (`"db.migrate"`) when registering hooks.

## The Hooks System

Hooks are functions that run at specific points in the pipeline. They let you intercept, validate, or transform without touching handler logic—keeping concerns separated.

### Three Phases

**Pre-dispatch**: Runs before the handler. Can abort execution.

Use for: authentication checks, input validation, logging start time. The hook receives `ArgMatches` and `CommandContext` but returns no data—only success or failure.

```rust
Hooks::new().pre_dispatch(|matches, ctx| {
    if !is_authenticated() {
        return Err(HookError::pre_dispatch("authentication required"));
    }
    Ok(())
})
```

**Post-dispatch**: Runs after the handler, before rendering. Can transform data.

Use for: adding timestamps, filtering sensitive fields, data enrichment. The hook receives handler output as `serde_json::Value`, allowing generic transformations regardless of the handler's output type.

```rust
Hooks::new().post_dispatch(|_matches, _ctx, mut data| {
    if let Some(obj) = data.as_object_mut() {
        obj.insert("generated_at".into(), json!(Utc::now().to_rfc3339()));
    }
    Ok(data)
})
```

**Post-output**: Runs after rendering. Can transform the final string.

Use for: adding headers/footers, compression, logging. The hook receives `RenderedOutput`—an enum of `Text(String)`, `Binary(Vec<u8>, String)`, or `Silent`.

```rust
Hooks::new().post_output(|_matches, _ctx, output| {
    match output {
        RenderedOutput::Text(s) => {
            Ok(RenderedOutput::Text(format!("{}\n-- Generated by MyApp", s)))
        }
        other => Ok(other),
    }
})
```

### Hook Chaining

Multiple hooks per phase are supported. Pre-dispatch hooks run sequentially—first error aborts. Post-dispatch and post-output hooks *chain*: each receives the output of the previous, enabling composable transformations.

```rust
Hooks::new()
    .post_dispatch(add_metadata)      // Runs first
    .post_dispatch(filter_sensitive)  // Receives add_metadata's output
```

Order matters: `filter_sensitive` sees the metadata that `add_metadata` inserted.

### Attaching Hooks

Two approaches:

```rust
// Via AppBuilder.hooks() with dot-notation path
App::builder()
    .command("migrate", migrate_handler, "migrate.j2")
    .hooks("db.migrate", Hooks::new()
        .pre_dispatch(require_admin))
    .build()?

// Via command_with() inline
App::builder()
    .command_with("migrate", migrate_handler, |cfg| cfg
        .template("migrate.j2")
        .pre_dispatch(require_admin))
    .build()?
```

### Error Handling

When a hook returns `Err(HookError)`:
- Execution stops immediately
- Remaining hooks in that phase don't run
- For pre-dispatch: the handler never executes
- For post phases: the rendered output is discarded
- The error message becomes the command output

`HookError` includes the phase and an optional source error for context:

```rust
HookError::pre_dispatch("database connection failed")
    .with_source(db_error)
```

## Dispatch Details

When `app.run()` executes:

1. Clap parses the arguments
2. Outstanding traverses the `ArgMatches` subcommand chain to find the deepest match
3. It extracts the command path (e.g., `["db", "migrate"]`)
4. It looks up the handler for that path
5. It executes the handler with the appropriate `ArgMatches` slice

If no handler matches, `run()` returns `RunResult::NoMatch(matches)`, letting you fall back to manual dispatch:

```rust
match app.run_to_string(cmd, args) {
    RunResult::Handled(output) => println!("{}", output),
    RunResult::NoMatch(matches) => {
        // Your existing dispatch logic
        match matches.subcommand() {
            Some(("legacy", sub)) => legacy_handler(sub),
            _ => {}
        }
    }
}
```

This enables gradual adoption—Outstanding handles some commands while others use your existing code.

## What Outstanding Adds to Your Command

When you call `app.run()`, Outstanding augments your `clap::Command` with:

**Custom help subcommand**:
```
myapp help              # Main help
myapp help topic-name   # Specific topic
myapp help --page       # Use pager for long content
```

**Global `--output` flag**:
```
myapp list --output=json
myapp db status --output=yaml
```

Values: `auto`, `term`, `text`, `term-debug`, `json`, `yaml`, `xml`, `csv`

**Global `--output-file-path` flag**:
```
myapp list --output-file-path=results.txt
```

These flags are global—they apply to all subcommands. You can rename or disable them via `AppBuilder`:

```rust
App::builder()
    .output_flag(Some("format"))       // Rename to --format
    .no_output_file_flag()             // Disable file output
```
